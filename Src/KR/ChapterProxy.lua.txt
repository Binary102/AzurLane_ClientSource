slot0 = class("ChapterProxy", import(".NetProxy"))
slot0.CHAPTER_UPDATED = "ChapterProxy:CHAPTER_UPDATED"
slot0.CHAPTER_ADDED = "ChapterProxy:CHAPTER_ADDED"
slot0.CHAPTER_REMOVED = "ChapterProxy:CHAPTER_REMOVED"
slot0.CHAPTER_TIMESUP = "ChapterProxy:CHAPTER_TIMESUP"
slot0.CHAPTER_CELL_UPDATED = "ChapterProxy:CHAPTER_CELL_UPDATED"
slot0.SHAM_CHAPTER_UPDATED = "ChapterProxy:SHAM_CHAPTER_UPDATED"
slot0.SHAM_SHOP_UPDATED = "ChapterProxy:SHAM_SHOP_UPDATED"
slot0.GUILD_CHAPTER_UPDATED = "ChapterProxy:GUILD_CHAPTER_UPDATED"
slot0.LAST_MAP_FOR_ACTIVITY = "last_map_for_activity"
slot0.LAST_MAP = "last_map"

slot0.register = function (slot0)
	slot0:on(13001, function (slot0)
		slot1 = {}
		slot2 = pairs
		slot3 = slot0.data or {}

		for slot5, slot6 in slot2(slot3) do
			if slot6:getPlayType() == ChapterConst.TypeMainSub then
				slot1[slot5] = slot6
			end
		end

		slot0.data = {}

		for slot5, slot6 in ipairs(slot0.chapter_list) do
			if not pg.chapter_template[slot6.id] then
				Debugger.LogError("chapter_template not exist: " .. slot6.id)
			else
				slot7 = nil

				if slot0.fleet_list then
					slot8 = pg.chapter_template[slot6.id].map
					slot7 = {}

					for slot12, slot13 in ipairs(slot0.fleet_list) do
						if slot8 == slot13.map_id then
							table.insert(slot7, slot13)
						end
					end
				end

				if slot0.data[Chapter.New(slot6, slot7).id] then
					slot0:updateChapter(slot8)
				else
					slot0:addChapter(slot8)
				end
			end
		end

		for slot5, slot6 in pairs(slot1) do
			if slot0.data[slot5] then
				slot7.expireTime = slot6.expireTime
				slot7.awardIndex = slot6.awardIndex
			else
				slot0.data[slot5] = slot6
			end
		end

		if slot0.current_chapter and slot0.current_chapter.id > 0 then
			slot0.data[slot2] or Chapter.New({
				id = slot2
			}):update(slot0.current_chapter)

			if slot0.data[slot2] then
				slot0:updateChapter(slot3)
			else
				slot0:addChapter(slot3)
			end
		end

		slot0.repairTimes = slot0.daily_repair_count

		if slot0.react_chapter then
			slot0.remasterId = slot0.react_chapter.active_id
			slot0.remasterTime = slot0.react_chapter.active_timestamp
			slot0.remasterTickets = slot0.react_chapter.count
		end

		Map.lastMap = slot0:getLastMap(slot1.LAST_MAP)
		Map.lastMapForActivity = slot0:getLastMap(slot1.LAST_MAP_FOR_ACTIVITY)
	end)
	slot0:on(13105, function (slot0)
		if slot0:getActiveChapter() then
			slot2 = 0

			if _.any(slot0.ai_list, function (slot0)
				return slot0.item_type == ChapterConst.AttachOni
			end) then
				slot1:onOniEnter()
			end

			if #slot0.map_update > 0 then
				_.each(slot0.map_update, function (slot0)
					if slot0.item_type == ChapterConst.AttachStory and slot0.item_data == ChapterConst.StoryTrigger then
						slot1 = ChapterCell.New(slot0)

						if _.detect(slot0.cellAttachments, function (slot0)
							return slot0.row == slot0.row and slot0.column == slot0.column
						end) then
							if slot2.flag == 3 and slot1.flag == 4 then
								print("run")

								if pg.map_event_template[slot2.attachmentId].gametip ~= "" then
									pg.TipsMgr:GetInstance():ShowTips(i18n(slot3))
								end
							end

							slot2.attachment = slot1.attachment
							slot2.attachmentId = slot1.attachmentId
							slot2.flag = slot1.flag
							slot2.data = slot1.data
						else
							table.insert(slot0.cellAttachments, slot1)
						end

						return
					end

					if slot0.item_type ~= ChapterConst.AttachNone and slot0.item_type ~= ChapterConst.AttachBorn and slot0.item_type ~= ChapterConst.AttachBorn_Sub and slot0.item_type ~= ChapterConst.AttachOni_Target and slot0.item_type ~= ChapterConst.AttachOni then
						slot0:mergeChapterCell(ChapterCell.New(slot0))
					end
				end)

				slot2 = bit.bor(slot2, bit.bor(ChapterConst.DirtyAttachment, ChapterConst.DirtyAutoAction))
			end

			if #slot0.ai_list > 0 then
				_.each(slot0.ai_list, function (slot0)
					slot0:mergeChampion(ChapterChampion.New(slot0))
				end)

				slot2 = bit.bor(slot2, bit.bor(ChapterConst.DirtyChampion, ChapterConst.DirtyAutoAction))
			end

			slot0:updateChapter(slot1, slot2)
		end
	end)

	slot0.shamChapter = ShamChapter.New()
	slot0.shamShop = ShamBattleShop.New(0, {})

	slot0:on(23001, function (slot0)
		slot1 = slot0.sim_id

		if not ChapterConst.ActivateMirror then
			if not slot1 or not pg.sim_battle_template[slot1] then
				slot1 = os.server_date("*t", pg.TimeMgr.GetInstance():GetServerTime()).month
			end

			slot0.shamShop:update(slot1, slot0.shop_list or {})

			slot0.shamChapter.simId = slot1
		elseif not pg.sim_battle_template[slot1] then
			slot0.shamShop = nil
		else
			slot0.shamShop:update(slot1, slot0.shop_list or {})
		end

		slot0.shamChapter.shamResetCount = slot0.sham_count

		if slot0.shamChapter:isFirstDay() and slot0.shamChapter.shamResetCount == 0 then
			slot0.shamChapter.shamResetCount = 1
		end

		slot0.shamChapter.repairTimes = slot0.daily_repair_count

		if slot0.current_sham and slot0.current_sham.id > 0 and pg.sham_battle_template[slot0.current_sham.id] then
			slot0.shamChapter:update(slot0.current_sham)
		else
			slot0:localLoadShamChapter()
		end
	end)
	slot0:on(23009, function (slot0)
		slot1 = slot0:getShamChapter()

		if #slot0.cell_list > 0 then
			_.each(slot0.cell_list, function (slot0)
				slot0:mergeChapterCell(ChapterCell.New(slot0))
			end)
			slot0:updateShamChapter(slot1, bit.bor(ChapterConst.DirtyAttachment, ChapterConst.DirtyAutoAction))
		end
	end)

	slot0.guildChapter = GuildChapter.New()

	slot0:on(61001, function (slot0)
		if slot0 ~= nil then
			slot0.guildChapter = GuildChapter.New()
			slot0.guildChapter.shamResetCount = slot0.guild_count
			slot0.guildChapter.repairTimes = slot0.daily_repair_count

			if slot0.current_guild and slot0.current_guild.id > 0 and pg.sham_battle_template[slot0.current_guild.id] then
				slot0.guildChapter:update(slot0.current_guild)
			else
				slot0:localLoadGuildChapter()
			end
		end
	end)
	slot0:on(61009, function (slot0)
		slot1 = slot0:guildChapter()

		if #slot0.cell_list > 0 then
			_.each(slot0.cell_list, function (slot0)
				slot0:mergeChapterCell(ChapterCell.New(slot0))
			end)
			slot0:updateGuildChapter(slot1, bit.bor(ChapterConst.DirtyAttachment, ChapterConst.DirtyAutoAction))
		end
	end)

	slot0.timers = {}
	slot0.mapEliteFleetCache = {}
	slot0.escortChallengeTimes = 0

	slot0:buildEscortMaps()

	slot0.subNextReqTime = 0
	slot0.subRefreshCount = 0
	slot0.subProgress = 1
end

slot0.buildRemasterMaps = function (slot0)
	slot2 = pg.TimeMgr.GetInstance()

	_.each(pg.re_map_template.all, function (slot0)
		if pg.re_map_template[slot0].time == "always" or (slot0:parseTimeFromConfig(slot2[2], true) <= slot0:GetServerTime() and slot0:GetServerTime() <= slot0:parseTimeFromConfig(slot2[3], true)) then
			_.each(slot1.config_data, function (slot0)
				if not slot0[pg.chapter_template[slot0].map] then
					Map.New({
						id = slot1
					}):setRemaster(slot1.id)

					slot0[slot1] = Map.New()
				end
			end)
		end
	end)

	return {}
end

slot0.getActiveRemaster = function (slot0)
	if slot0.remasterId and slot0.remasterId > 0 and pg.TimeMgr.GetInstance():GetServerTime() < slot0.remasterTime then
		return slot0.remasterId
	end
end

slot0.getMaxEscortChallengeTimes = function (slot0)
	return pg.gameset.gardroad_count.key_value
end

slot0.buildEscortMaps = function (slot0)
	slot1 = {}

	if OPEN_ESCORT then
		_.each(pg.escort_map_template.all, function (slot0)
			table.insert(slot0, EscortInfo.New(slot0))
		end)

		for slot5, slot6 in ipairs(pg.gameset.gardroad_count.description[1]) do
			slot7 = pg.chapter_template[slot6]

			table.insert(_.detect(slot1, function (slot0)
				return slot0.id == slot0.map
			end).chapters, {
				escortId = slot6,
				chapter = Chapter.New({
					id = slot6
				})
			})
		end
	end

	slot0.escortMaps = slot1
end

slot0.resetEscortChallengeTimes = function (slot0)
	slot0.escortChallengeTimes = 0
end

slot0.checkMirrorCount = function (slot0)
	if slot0.shamChapter == nil then
		return
	end

	if ChapterConst.ActivateMirror and slot0.shamChapter:isFirstDay() and slot0.shamChapter.shamResetCount == 0 then
		slot0.shamChapter.shamResetCount = 1
	end
end

slot0.addChapterListener = function (slot0, slot1)
	if not slot1.dueTime or not slot0.timers then
		return
	end

	if slot0.timers[slot1.id] then
		slot0.timers[slot1.id]:Stop()

		slot0.timers[slot1.id] = nil
	end

	function slot3()
		slot0.data[slot1.id].dueTime = nil

		slot0.data[slot1.id].data[nil.id]:display("times'up")
		slot0.data[slot1.id].data[nil.id].display:sendNotification("times'up".CHAPTER_UPDATED, {
			dirty = 0,
			chapter = slot0.data[slot1.id]:clone()
		})
		slot0.data[slot1.id].data[nil.id].display.sendNotification:sendNotification("times'up".CHAPTER_UPDATED.CHAPTER_TIMESUP)
	end

	if slot1.dueTime - pg.TimeMgr.GetInstance():GetServerTime() > 0 then
		slot0.timers[slot1.id] = Timer.New(function ()
			slot0()
			slot1.timers[slot2.id]:Stop()

			slot1.timers[slot2.id] = nil
		end, slot2, 1)

		slot0.timers[slot1.id]:Start()
	else
		slot3()
	end
end

slot0.removeChapterListener = function (slot0, slot1)
	if slot0.timers[slot1] then
		slot0.timers[slot1]:Stop()

		slot0.timers[slot1] = nil
	end
end

slot0.remove = function (slot0)
	for slot4, slot5 in pairs(slot0.timers) do
		slot5:Stop()
	end

	slot0.timers = nil
end

slot0.existChapter = function (slot0, slot1)
	return slot0.data[slot1] ~= nil
end

slot0.getChapterById = function (slot0, slot1)
	if slot0.data[slot1] then
		return slot0.data[slot1]:clone()
	else
		slot2 = Chapter.New({
			id = slot1
		})
		slot3 = slot2:getConfig("map")

		if slot2:getConfig("type") == Chapter.CustomFleet and slot0.mapEliteFleetCache[slot3] then
			slot2:setEliteFleetList(slot0.mapEliteFleetCache[slot3])
		end

		return slot2
	end
end

slot0.addChapter = function (slot0, slot1)
	slot0.data[slot1.id] = slot1:clone()

	slot0:addChapterListener(slot1)
	slot0.facade:sendNotification(slot0.CHAPTER_ADDED, {
		dirty = -1,
		chapter = slot1:clone()
	})
end

slot0.updateChapter = function (slot0, slot1, slot2)
	slot3 = slot0.data[slot1.id]
	slot0.data[slot1.id] = slot1:clone()

	if not slot1:inWartime() then
		slot0:removeChapterListener(slot1.id)
	elseif not slot3 or slot3.dueTime ~= slot1.dueTime then
		slot0:addChapterListener(slot1)
	end

	slot0.facade:sendNotification(slot0.CHAPTER_UPDATED, {
		chapter = slot1:clone(),
		dirty = defaultValue(slot2, 0)
	})

	if slot0.data[slot1.id] and slot0.data[slot1.id].fleet then
		slot0.data[slot1.id].fleet:clearShipHpChange()
	end
end

slot0.removeChapter = function (slot0, slot1)
	if slot0.data[slot1] then
		slot0:removeChapterListener(slot1)

		slot0.data[slot1] = nil

		slot0.facade:sendNotification(slot0.CHAPTER_REMOVED, {
			dirty = -1,
			chapter = slot0.data[slot1]
		})
	end
end

slot0.duplicateEliteFleet = function (slot0, slot1, slot2)
	if slot1:getConfig("type") == Chapter.CustomFleet then
		slot1:EliteShipTypeFilter()

		slot0.mapEliteFleetCache[slot1:getConfig("map")] = slot1:getEliteFleetList()
		slot5 = {}

		for slot9, slot10 in pairs(slot0.data) do
			if slot10:getConfig("map") == slot4 and slot10.configId ~= slot1.configId then
				slot10:setEliteFleetList(slot3)

				if slot2 then
					slot0:updateChapter(slot10)
				end
			end
		end
	end
end

slot0.getSameMapChapters = function (slot0, slot1)
	slot2 = {}

	if slot1:getConfig("type") == Chapter.CustomFleet then
		slot3 = slot1:getConfig("map")

		for slot7, slot8 in pairs(slot0.data) do
			if slot8:getConfig("map") == slot3 and slot8.configId ~= slot1.configId then
				table.insert(slot2, slot8)
			end
		end
	end

	return slot2
end

slot0.getMaps = function (slot0)
	slot1 = {}
	slot2 = pg.expedition_data_by_map
	slot3 = (OPEN_REMASTER and slot0:buildRemasterMaps()) or {}

	for slot7, slot8 in ipairs(slot2.all) do
		slot1[slot8] = slot3[slot8] or Map.New({
			id = slot8
		})
	end

	slot5 = getProxy(BayProxy).getRawData(slot4)

	for slot10, slot11 in ipairs(Chapter.bindConfigTable().all) do
		slot13 = slot1[slot6[slot11].map]

		if slot0.data[slot6[slot11].id] then
			for slot18, slot19 in ipairs(slot14:getEliteFleetList()) do
				slot20 = #slot19

				while slot20 > 0 do
					if slot5[slot19[slot20]] == nil then
						table.remove(slot19, slot20)
					end

					slot20 = slot20 - 1
				end
			end
		end

		slot15 = nil

		if slot14 then
			slot15 = slot14:clone()

			slot0:duplicateEliteFleet(slot14)
		elseif slot12.model ~= ChapterConst.TypeMainSub and Chapter.New({
			id = slot12.id
		}).getConfig(slot15, "type") == Chapter.CustomFleet and slot0.mapEliteFleetCache[slot13.configId] then
			slot15:setEliteFleetList(slot0.mapEliteFleetCache[slot13.configId])
		end

		if slot15 and slot15:isValid() then
			slot13:updateChapter(slot15)
		end
	end

	slot7 = true
	slot9 = getProxy(PlayerProxy).getData(slot8)
	slot10 = nil

	for slot14, slot15 in ipairs(slot2.all) do
		slot17 = slot1[slot15 + 1]

		slot1[slot15].updateChapters(slot16, slot10)

		slot18 = slot1[slot15].getConfig(slot16, "level_limit")

		if slot1[slot15].getMapType(slot16) == Map.SCENARIO then
			slot16:setUnlock(slot7 and slot18 <= slot9.level)

			if slot17 then
				slot7 = slot16:isClear() and slot17:getConfig("level_limit") <= slot9.level
			else
				slot7 = slot16:isClear()
			end
		elseif slot16:isActivity() then
			slot16:setUnlock(slot18 <= slot9.level and slot16:isAnyChapterUnlocked())
		else
			slot16:setUnlock(slot18 <= slot9.level)
		end

		slot10 = slot16

		if slot1[slot16:getBindMap()] then
			slot16:setBindMapVO(slot1[slot19])
		end
	end

	slot11 = {}
	slot13 = (slot0:getActiveChapter() and slot12.id) or 0

	for slot17, slot18 in pairs(slot1) do
		slot19 = _.any(_.values(slot18.chapters), function (slot0)
			return slot0.id == slot0
		end)

		if not slot18:isInValidMap() or slot19 then
			slot11[slot18.id] = slot18
		end
	end

	return slot11
end

slot0.getActiveChapter = function (slot0)
	for slot4, slot5 in pairs(slot0.data) do
		if slot5.active then
			return slot5:clone()
		end
	end
end

slot0.getNonActActiveChapter = function (slot0)
	for slot4, slot5 in pairs(slot0.data) do
		if not slot5:isActivity() and slot5.active then
			return slot5:clone()
		end
	end
end

slot0.getActActiveChapter = function (slot0)
	for slot4, slot5 in pairs(slot0.data) do
		if slot5:isActivity() and slot5.active then
			return slot5:clone()
		end
	end
end

slot0.getUnlockActMapBytype = function (slot0, slot1, slot2)
	slot3 = {}

	for slot8, slot9 in pairs(slot4) do
		if slot9:getConfig("type") == slot1 and slot9:getConfig("on_activity") == slot2 then
			table.insert(slot3, slot9)
		end
	end

	for slot8, slot9 in ipairs(slot3) do
		if slot9:getActiveChapter() then
			return slot9
		end
	end

	for slot8, slot9 in ipairs(slot3) do
		if slot4[slot9.id - 1] and slot10:isClearForActivity() and slot9:isUnlock() then
			return slot9
		end
	end

	table.sort(slot3, function (slot0, slot1)
		return slot0.id < slot1.id
	end)

	return slot3[1]
end

slot0.getLastMapForActivity = function (slot0)
	slot2, slot3 = nil

	if getProxy(ChapterProxy):getActActiveChapter() then
		slot2 = slot1.id
		slot3 = slot1:getConfig("map")
	else
		slot4 = slot0:getMaps()

		function slot5(slot0)
			return getProxy(ActivityProxy):getActivityById(slot0:getConfig("on_activity")) and not slot2:isEnd()
		end

		if Map.lastMapForActivity and slot4[Map.lastMapForActivity] and slot4[Map.lastMapForActivity]:isActivity() and slot5(slot4[Map.lastMapForActivity]) then
			slot3 = Map.lastMapForActivity
		else
			if Map.lastMapForActivity then
				Map.lastMapForActivity = nil

				slot0:recordLastMap(slot0.LAST_MAP_FOR_ACTIVITY, 0)
			end

			table.sort(slot6, function (slot0, slot1)
				return slot0.id < slot1.id
			end)

			if #getProxy(ActivityProxy):getActivitiesByType(ActivityConst.ACTIVITY_TYPE_ZPROJECT) > 0 then
				_.each(slot6, function (slot0)
					if _.all(_.select(_.values(slot0), function (slot0)
						return slot0:getConfig("on_activity") == slot0.id
					end), function (slot0)
						return slot0:isActivity() and slot0:getConfig("type") == Map.EVENT
					end) then
						_.each(slot1, function (slot0)
							if slot0:isUnlock() then
								slot0 = slot0.id
							end
						end)
					elseif _.any(slot1, function (slot0)
						return slot0:getConfig("type") == Map.ACTIVITY_EASY and not slot0:isClearForActivity()
					end) then
						_.each(slot1, function (slot0)
							if slot0:getConfig("type") == Map.ACTIVITY_EASY and slot0:isUnlock() then
								slot0 = slot0.id
							end
						end)
					else
						_.each(slot1, function (slot0)
							if slot0:getConfig("type") == Map.ACTIVITY_HARD and slot0:isUnlock() then
								slot0 = slot0.id
							end
						end)
					end
				end)
			end

			slot3 = slot3 or ActivityConst.ACTIVITY_BATTLE_MAP_ID
		end
	end

	return slot3, slot2
end

slot0.inWarTime = function (slot0)
	if slot0:getActiveChapter() then
		return slot1:inWartime()
	end
end

slot0.isInVaildFleet = function (slot0)
	return not slot0:getActiveChapter() or not slot1.fleet:isValid()
end

slot0.checkNextFleet = function (slot0)
	return not slot0:getActiveChapter() or slot1.fleet:isValid() or slot1:getNextValidIndex() <= 0
end

slot0.inChapterLine = function (slot0, slot1)
	if slot0:getActiveChapter() and slot2.fleet.line.row == slot1.row and slot2.fleet.line.column == slot1.column then
		if slot1.attachment and slot1.flag then
			return slot0:getChapterCell(slot1)
		end

		return true
	end
end

slot0.getChapterCell = function (slot0, slot1)
	if slot0:getActiveChapter() then
		return slot2:getChapterCell(slot1.row, slot1.column).attachment == slot1.attachment and slot3.flag == slot1.flag
	end
end

slot0.updateActiveChapterShips = function (slot0)
	for slot4, slot5 in pairs(slot0.data) do
		if slot5.active then
			_.each(slot5.fleets, function (slot0)
				slot0:flushShips()
			end)
		end
	end
end

slot0.resetRepairTimes = function (slot0)
	slot0.repairTimes = 0
end

slot0.getUseableEliteMap = function (slot0)
	slot2 = {}

	for slot6, slot7 in pairs(slot1) do
		if slot7:getMapType() == Map.ELITE and slot7:isEliteEnabled() then
			slot2[#slot2 + 1] = slot7
		end
	end

	return slot2
end

slot0.getUseableActivityMap = function (slot0)
	slot2 = {}

	for slot6, slot7 in pairs(slot1) do
		if slot7:getMapType() == Map.ACTIVITY_HARD then
			slot2[#slot2 + 1] = slot7
		end
	end

	return slot2
end

slot0.getUseableMaxEliteMap = function (slot0)
	if #slot0:getUseableEliteMap() == 0 then
		return false
	end

	table.sort(slot1, function (slot0, slot1)
		return slot1.configId < slot0.configId
	end)

	return slot1[1]
end

slot0.eliteFleetRecommend = function (slot0, slot1, slot2)
	slot3 = getProxy(BayProxy)
	slot4 = slot1:getEliteFleetList()[slot2]
	slot6 = {}
	slot7 = {}
	slot8 = {
		0,
		0,
		0
	}

	if slot1:getConfig("limitation")[slot2] then
		slot6 = Clone(slot5[1])
		slot7 = Clone(slot5[2])
	end

	slot9 = getProxy(BayProxy):getRawData()
	slot10 = {}

	for slot14, slot15 in ipairs(slot1:getEliteFleetList()) do
		for slot19, slot20 in ipairs(slot15) do
			slot10[#slot10 + 1] = slot20
		end
	end

	slot11 = {
		[TeamType.Main] = slot6,
		[TeamType.Vanguard] = slot7,
		[TeamType.Submarine] = slot8
	}

	for slot15, slot16 in ipairs(slot4) do
		slot20 = 0
		slot21 = nil
		slot20 = (table.contains(slot11[pg.ship_data_by_type[slot9[slot16].getShipType(slot17)].team_type], slot9[slot16].getShipType(slot17)) and slot18) or 0

		for slot25, slot26 in ipairs(slot21) do
			if slot26 == slot20 then
				table.remove(slot21, slot25)

				break
			end
		end
	end

	function slot12(slot0)
		if slot0:getEliteRecommendShip(slot0, slot0.getEliteRecommendShip) then
			slot1[#slot1 + 1] = slot1.id
			slot1.id[#slot2 + 1] = slot1.id
		end
	end

	if slot2 >= 1 and slot2 <= 2 then
		for slot16, slot17 in ipairs(slot6) do
			slot18 = nil

			if type(slot17) == "string" then
				slot18 = Clone(ShipType.BundleList[slot17])
			elseif type(slot17) == "number" then
				slot12((slot17 ~= 0 or TeamType.MainShipType) and {
					slot17
				})
			end
		end

		for slot16, slot17 in ipairs(slot7) do
			slot18 = nil

			if type(slot17) == "string" then
				slot18 = Clone(ShipType.BundleList[slot17])
			elseif type(slot17) == "number" then
				slot12((slot17 ~= 0 or TeamType.VanguardShipType) and {
					slot17
				})
			end
		end
	else
		for slot16, slot17 in ipairs(slot8) do
			slot18 = nil

			if type(slot17) == "string" then
				slot18 = Clone(ShipType.BundleList[slot17])
			elseif type(slot17) == "number" then
				slot12((slot17 ~= 0 or TeamType.SubShipType) and {
					slot17
				})
			end
		end
	end
end

slot0.isClear = function (slot0, slot1)
	return slot0:getChapterById(slot1) and slot2:isClear()
end

slot0.getShamChapter = function (slot0)
	return Clone(slot0.shamChapter)
end

slot0.updateShamChapter = function (slot0, slot1, slot2)
	slot0.shamChapter = slot1

	slot0.facade:sendNotification(slot0.SHAM_CHAPTER_UPDATED, {
		shamChapter = slot1:clone(),
		dirty = defaultValue(slot2, 0)
	})
	slot0.shamChapter.fleet:clearShipHpChange()
end

slot0.updateShamChapterShips = function (slot0)
	slot0.shamChapter:flushShips()
end

slot0.localSaveShamChapter = function (slot0)
	slot0.shamChapter:localSaveChapter()
end

slot0.resetShamChapter = function (slot0)
	slot0.shamChapter.shamResetCount = 0
	slot0.shamChapter.repairTimes = 0
end

slot0.getShamShop = function (slot0)
	return Clone(slot0.shamShop)
end

slot0.updateShamShop = function (slot0, slot1)
	slot0.shamShop = slot1

	slot0:sendNotification(slot0.SHAM_SHOP_UPDATED)
end

slot0.localLoadShamChapter = function (slot0)
	slot0.shamChapter:localLoadChapter()
end

slot0.getGuildChapter = function (slot0)
	return Clone(slot0.guildChapter)
end

slot0.localLoadGuildChapter = function (slot0)
	slot0.guildChapter:localLoadChapter()
end

slot0.localSaveGuildChapter = function (slot0)
	slot0.guildChapter:localSaveChapter()
end

slot0.updateGuildChapter = function (slot0, slot1, slot2)
	slot0.guildChapter = slot1

	slot0.facade:sendNotification(slot0.GUILD_CHAPTER_UPDATED, {
		guildChapter = slot1:clone(),
		dirty = defaultValue(slot2, 0)
	})
	slot0.guildChapter.fleet:clearShipHpChange()
end

slot0.updateGuildChapterShips = function (slot0)
	if slot0.guildChapter then
		slot0.guildChapter:flushShips()
	end
end

slot0.getEscortShop = function (slot0)
	return Clone(slot0.escortShop)
end

slot0.updateEscortShop = function (slot0, slot1)
	slot0.escortShop = slot1
end

slot0.removeEscortChapter = function (slot0, slot1)
	for slot5, slot6 in pairs(slot0.escortMaps) do
		for slot10 = #slot6.chapters, 1, -1 do
			if slot6.chapters[slot10].chapter.id == slot1 then
				table.remove(slot6.chapters, slot10)
			end
		end
	end
end

slot0.recordLastMap = function (slot0, slot1, slot2)
	slot3 = false

	if slot1 == slot0.LAST_MAP_FOR_ACTIVITY then
		Map.lastMapForActivity = slot2
		slot3 = true
	elseif slot1 == slot0.LAST_MAP and slot2 ~= Map.lastMap then
		Map.lastMap = slot2
		slot3 = true
	end

	if slot3 then
		PlayerPrefs.SetInt(slot1 .. getProxy(PlayerProxy):getRawData().id, slot2)
		PlayerPrefs.Save()
	end
end

slot0.getLastMap = function (slot0, slot1)
	if PlayerPrefs.GetInt(slot1 .. getProxy(PlayerProxy):getRawData().id) ~= 0 then
		return slot3
	end
end

slot0.getChapterCommandes = function (slot0)
	slot1 = {}

	for slot5, slot6 in pairs(slot0.data) do
		for slot11, slot12 in pairs(slot7) do
			for slot16, slot17 in pairs(slot12) do
				table.insert(slot1, slot17)
			end
		end
	end

	return slot1
end

slot0.getFleetCommander = function (slot0, slot1, slot2)
	for slot6, slot7 in pairs(slot0.data) do
		if slot7.id == slot1 then
			for slot12, slot13 in pairs(slot8) do
				if slot2 == slot12 then
					return slot13
				end
			end
		end
	end
end

slot0.getOtherFleetCommander = function (slot0, slot1, slot2)
	slot3 = {}

	for slot7, slot8 in pairs(slot0.data) do
		if slot8.id == slot1 then
			for slot13, slot14 in pairs(slot9) do
				if slot2 ~= slot13 then
					table.insert(slot3, slot14)
				end
			end
		end
	end

	return slot3
end

return slot0
